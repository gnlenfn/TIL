# CPU 스케쥴링

State: Writing
유형: 강의
최종 편집: 2021년 11월 2일 오후 9:17

# 사용자 프로그램의 수행 과정

I/O 버스트와 CPU 버스트의 반복

대부분 I/O 바운드 프로세스 (I/O 요청이 빈번해 CPU 버스트 시간이 짧은 프로그램)

I/O 바운드 프로세스의 경우 CPU가 놀고있는 시간이 많기 때문에 자원을 효율적으로 쓰기 위해 CPU 스케쥴링이 필요하다

CPU 바운드 프로세스는 수행의 상당 시간을 CPU작업에 소모하는 계산 위주의 프로그램

두 가지 종류의 프로세스를 효율적으로 수행하기 위해 CPU스케쥴링이 필요

# CPU 스케쥴러

준비 상태에 있는 프로세스들 중 어떤 프로세스에게 CPU를 할당할 것인지 결정하는 운영체제의 코드

- 비선점형(nonpreemptive)
    - CPU를 획득한 프로세스가 스스로 반납하기 전까지는 CPU를 빼앗기지 않는 방식
    - 응답시간 예측이 편리하고 일괄처리에 적합
    - 덜 중요한 작업이 CPU를 할당 받으면 중요한 작업이 대기해야 함
- 선점형(preemptive)
    - 프로세스가 CPU를 계속 사용하길 원하더라도 강제로 빼앗을 수 있는 방식
    - 우선순위가 더 높은 프로세스가 생겼을 때 빠르게 처리할 수 있음
    - 빠른 응답시간을 요구하는 시스템에서 유용
    - 빈번한 context switch 생김

# 디스패처

새롭게 선택된 프로세스가 CPU를 할당받고 작업으 수행할 수 있도록 환경설정을 하는 운영체제의 코드

디스패처는 현재 수행중이던 프로세스의 문맥을 그 프로세스의 PCB에 저장하고 새롭게 선택된 프로세스의 문맥을 해당 프로세스의 PCB에서 가져와 그 프로세스를 CPU에 넘기는 작업을 수행

디스패처가 하나의 프로세스를 정지시키고 다른 프로세스에게 CPU를 전달하기까지 걸리는 시간을 디스패치 지연시간(dispatch latency)라고 하며 대부분의 지연시간은 문맥교환 오버헤드에 해당

# 스케쥴링 성능 평가

1. CPU 이용율
    - 전체 시간 중에서 CPU가 일을 한 시간의 비율
    - CPU가 일하지 않고 휴면(idle) 상태에 있는 시간을 최대한 줄이는 것이 CPU 스케쥴링의 목표
2. 처리량
    - 주어진 시간 동안 준비 큐에서 기다리고 있는 프로세스 중 몇 개를 끝냈는지
    - 준비 큐에서 대기하는 프로세스 중 몇 개가 CPU 버스트를 끝내고 준비큐를 떠났는지 측정
    - CPU 버스트가 짧은 프로세스를 우선 처리하는 것이 처리량 상승에 유리
3. 소요시간
    - CPU를 요청한 시점부터 CPU 버스트가 끝날 때까지 걸린 시간
    - 준비큐 대기시간 + 실제 CPU 사용시간 (1개의 CPU 버스트 만큼)
    - 프로그램이 종료되기까지 걸린 시간이 아님 주의
4. 대기시간
    - CPU 버스트 기간 중 프로세스가 준비 큐에서 기다린 시간의 합
    - 시분할 시스템에서는 하나의 CPU버스트 중에서도 여러번 준비 큐에서 대기할 수 있음
    - 이번 CPU 버스트가 끝나기까지 준비 큐에서 대기한 모든 시간의 합
5. 응답시간
    - 준비 큐에 들어온 후 첫 번째 CPU를 획득하기 까지 걸린 시간
    - 대화형 시스템에 적합한 성능 척도 → 사용자 입장에서 가장 중요한 성능 척도

# 스케쥴링 알고리즘

### 비선점 방식

- FCFS : First Come First Served
    - 선입선출, 아무도 안씀
    - 실행 시간이 짧은 프로세스가 긴 프로세스 뒤에 오면 평균 대기시간 급증 (Convoy effect)
- SJF : Shortest Job First (SRTF : Shortest Remaining Time First)
    - 계속해서 짧은 시간의 프로세스가 들어오면 실행 시간이 긴 작업은 실행되지 못함 (starving)

### 선점 방식

- RR : Round-Robin
    - time-sharing과 관련이 깊다
    - CPU 사용시간에 limit을 걸어두는 로직으로 모든 프로세스가 같은 단위 시간만큼 CPU 사용을 보장받는다
        - 단위 시간이 너무 짧으면 잦은 문맥 교환으로 오버헤드 증가
        - 단위 시간이 너무 길면 FCFS와 다름없다
- Priority-based
    - 준비 큐의 프로세스에 우선순위를 부여하고 우선순위에 따라 CPU를 할당
    - 우선 순위가 낮은 작업에 대해 starvation 문제 발생
        - Aging기법 사용 → 준비 큐에서 오래 기다릴 수록 우선순위를 조금씩 높여줌
        
- Multi-Level Feedback Queue
    - 현대적인 스케쥴러의 형태
    - 우선순위가 낮은 준비 큐는 큰 Time Quantum을 줌
    - 맨 아래 큐에서 너무 오래 대기하면 다시 상위큐로 이동 (Aging 기법)
    
    ![Untitled](CPU%20%E1%84%89%E1%85%B3%E1%84%8F%E1%85%A6%E1%84%8C%E1%85%B2%E1%86%AF%E1%84%85%E1%85%B5%E1%86%BC%2003ba1776602e480dba7f9473319f3de6/Untitled.png)